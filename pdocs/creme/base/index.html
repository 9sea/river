<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.5" />
<title>creme.base API documentation</title>
<meta name="description" content="Base interfaces …" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>creme.base</code></h1>
</header>
<section id="section-intro">
<p>Base interfaces.</p>
<p>Every estimator in <code>creme</code> is a class, and as such inherits from at least one base interface.
These are used to categorize, organize, and standardize the many estimators that <code>creme</code>
contains.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Base interfaces.

Every estimator in ``creme`` is a class, and as such inherits from at least one base interface.
These are used to categorize, organize, and standardize the many estimators that ``creme``
contains.

&#34;&#34;&#34;
from .anomaly import AnomalyDetector
from .classifier import Classifier
from .classifier import BinaryClassifier
from .classifier import MultiClassifier
from .clusterer import Clusterer
from .ensemble import Ensemble
from .estimator import Estimator
from .multi_output import MultiOutputClassifier
from .multi_output import MultiOutputRegressor
from .regressor import Regressor
from .transformer import Transformer
from .wrapper import Wrapper


__all__ = [
    &#39;AnomalyDetector&#39;,
    &#39;BinaryClassifier&#39;,
    &#39;Classifier&#39;,
    &#39;Clusterer&#39;,
    &#39;Ensemble&#39;,
    &#39;Estimator&#39;,
    &#39;MultiClassifier&#39;,
    &#39;MultiOutputClassifier&#39;,
    &#39;MultiOutputRegressor&#39;,
    &#39;Regressor&#39;,
    &#39;Transformer&#39;,
    &#39;Wrapper&#39;
]</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="creme.base.anomaly" href="anomaly.html">creme.base.anomaly</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="creme.base.classifier" href="classifier.html">creme.base.classifier</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="creme.base.clusterer" href="clusterer.html">creme.base.clusterer</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="creme.base.ensemble" href="ensemble.html">creme.base.ensemble</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="creme.base.estimator" href="estimator.html">creme.base.estimator</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="creme.base.multi_output" href="multi_output.html">creme.base.multi_output</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="creme.base.regressor" href="regressor.html">creme.base.regressor</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="creme.base.test_base" href="test_base.html">creme.base.test_base</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="creme.base.transformer" href="transformer.html">creme.base.transformer</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="creme.base.wrapper" href="wrapper.html">creme.base.wrapper</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="creme.base.AnomalyDetector"><code class="flex name class">
<span>class <span class="ident">AnomalyDetector</span></span>
</code></dt>
<dd>
<section class="desc"><p>An estimator.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AnomalyDetector(estimator.Estimator):

    @abc.abstractmethod
    def fit_one(self, x: dict) -&gt; &#39;AnomalyDetector&#39;:
        &#34;&#34;&#34;Updates the model.&#34;&#34;&#34;

    @abc.abstractmethod
    def score_one(self, x: dict) -&gt; float:
        &#34;&#34;&#34;Returns an outlier score.

        The range of the score depends on each model. Some models will output anomaly scores
        between 0 and 1, others will not. In any case, the lower the score, the more likely it is
        that ``x`` is an anomaly.

        &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="creme.base.estimator.Estimator" href="estimator.html#creme.base.estimator.Estimator">Estimator</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>creme.anomaly.hst.HalfSpaceTrees</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="creme.base.AnomalyDetector.fit_one"><code class="name flex">
<span>def <span class="ident">fit_one</span></span>(<span>self, x: dict) -> <a title="creme.base.anomaly.AnomalyDetector" href="anomaly.html#creme.base.anomaly.AnomalyDetector">AnomalyDetector</a></span>
</code></dt>
<dd>
<section class="desc"><p>Updates the model.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def fit_one(self, x: dict) -&gt; &#39;AnomalyDetector&#39;:
    &#34;&#34;&#34;Updates the model.&#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="creme.base.AnomalyDetector.score_one"><code class="name flex">
<span>def <span class="ident">score_one</span></span>(<span>self, x: dict) -> float</span>
</code></dt>
<dd>
<section class="desc"><p>Returns an outlier score.</p>
<p>The range of the score depends on each model. Some models will output anomaly scores
between 0 and 1, others will not. In any case, the lower the score, the more likely it is
that <code>x</code> is an anomaly.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def score_one(self, x: dict) -&gt; float:
    &#34;&#34;&#34;Returns an outlier score.

    The range of the score depends on each model. Some models will output anomaly scores
    between 0 and 1, others will not. In any case, the lower the score, the more likely it is
    that ``x`` is an anomaly.

    &#34;&#34;&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="creme.base.BinaryClassifier"><code class="flex name class">
<span>class <span class="ident">BinaryClassifier</span></span>
</code></dt>
<dd>
<section class="desc"><p>A binary classifier.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BinaryClassifier(Classifier):
    &#34;&#34;&#34;A binary classifier.&#34;&#34;&#34;

    @abc.abstractmethod
    def fit_one(self, x: dict, y: bool) -&gt; &#39;BinaryClassifier&#39;:
        &#34;&#34;&#34;Fits to a set of features ``x`` and a boolean target ``y``.

        Parameters:
            x (dict)
            y (bool)

        Returns:
            self

        &#34;&#34;&#34;

    @abc.abstractmethod
    def predict_proba_one(self, x: dict) -&gt; typing.Dict[bool, float]:
        &#34;&#34;&#34;Predicts the probability output of a set of features ``x``.

        Parameters:
            x (dict)

        Returns:
            dict of floats

        &#34;&#34;&#34;

    def predict_one(self, x: dict) -&gt; bool:
        &#34;&#34;&#34;Predicts the target value of a set of features ``x``.

        Parameters:
            x (dict)

        Returns:
            bool

        &#34;&#34;&#34;
        y_pred = self.predict_proba_one(x)
        return y_pred[True] &gt; y_pred[False]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="creme.base.classifier.Classifier" href="classifier.html#creme.base.classifier.Classifier">Classifier</a></li>
<li><a title="creme.base.estimator.Estimator" href="estimator.html#creme.base.estimator.Estimator">Estimator</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>creme.ensemble.stacking.StackingBinaryClassifier</li>
<li>creme.facto.ffm.FFMClassifier</li>
<li>creme.facto.fm.FMClassifier</li>
<li>creme.facto.fwfm.FwFMClassifier</li>
<li>creme.facto.hofm.HOFMClassifier</li>
<li>creme.linear_model.alma.ALMAClassifier</li>
<li>creme.linear_model.glm.LogisticRegression</li>
<li>creme.linear_model.pa.PAClassifier</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="creme.base.BinaryClassifier.fit_one"><code class="name flex">
<span>def <span class="ident">fit_one</span></span>(<span>self, x: dict, y: bool) -> <a title="creme.base.classifier.BinaryClassifier" href="classifier.html#creme.base.classifier.BinaryClassifier">BinaryClassifier</a></span>
</code></dt>
<dd>
<section class="desc"><p>Fits to a set of features <code>x</code> and a boolean target <code>y</code>.</p>
<h2 id="parameters">Parameters</h2>
<p>x (dict)
y (bool)</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>self</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def fit_one(self, x: dict, y: bool) -&gt; &#39;BinaryClassifier&#39;:
    &#34;&#34;&#34;Fits to a set of features ``x`` and a boolean target ``y``.

    Parameters:
        x (dict)
        y (bool)

    Returns:
        self

    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="creme.base.BinaryClassifier.predict_one"><code class="name flex">
<span>def <span class="ident">predict_one</span></span>(<span>self, x: dict) -> bool</span>
</code></dt>
<dd>
<section class="desc"><p>Predicts the target value of a set of features <code>x</code>.</p>
<h2 id="parameters">Parameters</h2>
<p>x (dict)</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def predict_one(self, x: dict) -&gt; bool:
    &#34;&#34;&#34;Predicts the target value of a set of features ``x``.

    Parameters:
        x (dict)

    Returns:
        bool

    &#34;&#34;&#34;
    y_pred = self.predict_proba_one(x)
    return y_pred[True] &gt; y_pred[False]</code></pre>
</details>
</dd>
<dt id="creme.base.BinaryClassifier.predict_proba_one"><code class="name flex">
<span>def <span class="ident">predict_proba_one</span></span>(<span>self, x: dict) -> Dict[bool, float]</span>
</code></dt>
<dd>
<section class="desc"><p>Predicts the probability output of a set of features <code>x</code>.</p>
<h2 id="parameters">Parameters</h2>
<p>x (dict)</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code> of <code>floats</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def predict_proba_one(self, x: dict) -&gt; typing.Dict[bool, float]:
    &#34;&#34;&#34;Predicts the probability output of a set of features ``x``.

    Parameters:
        x (dict)

    Returns:
        dict of floats

    &#34;&#34;&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="creme.base.Classifier"><code class="flex name class">
<span>class <span class="ident">Classifier</span></span>
</code></dt>
<dd>
<section class="desc"><p>A classifier.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Classifier(estimator.Estimator):
    &#34;&#34;&#34;A classifier.&#34;&#34;&#34;

    @abc.abstractmethod
    def fit_one(self, x, y):
        &#34;&#34;&#34;Fits to a set of features ``x`` and a label ``y``.

        Parameters:
            x (dict)
            y (Label)

        Returns:
            self

        &#34;&#34;&#34;

    @abc.abstractmethod
    def predict_proba_one(self, x):
        &#34;&#34;&#34;Predicts the probability output of a set of features ``x``.&#34;&#34;&#34;

    def predict_one(self, x: dict) -&gt; typing.Union[typing.Hashable, None]:
        &#34;&#34;&#34;Predicts the target value of a set of features ``x``.

        Parameters:
            x (dict)

        Returns:
            Label

        &#34;&#34;&#34;
        y_pred = self.predict_proba_one(x)
        if y_pred:
            return max(y_pred, key=y_pred.get)
        return None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="creme.base.estimator.Estimator" href="estimator.html#creme.base.estimator.Estimator">Estimator</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="creme.base.classifier.BinaryClassifier" href="classifier.html#creme.base.classifier.BinaryClassifier">BinaryClassifier</a></li>
<li><a title="creme.base.classifier.MultiClassifier" href="classifier.html#creme.base.classifier.MultiClassifier">MultiClassifier</a></li>
<li>creme.ensemble.bagging.BaggingClassifier</li>
<li>creme.ensemble.boosting.AdaBoostClassifier</li>
<li>creme.model_selection.sh.SuccessiveHalvingClassifier</li>
<li>creme.sampling.random.ClassificationSampler</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="creme.base.Classifier.fit_one"><code class="name flex">
<span>def <span class="ident">fit_one</span></span>(<span>self, x, y)</span>
</code></dt>
<dd>
<section class="desc"><p>Fits to a set of features <code>x</code> and a label <code>y</code>.</p>
<h2 id="parameters">Parameters</h2>
<p>x (dict)
y (Label)</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>self</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def fit_one(self, x, y):
    &#34;&#34;&#34;Fits to a set of features ``x`` and a label ``y``.

    Parameters:
        x (dict)
        y (Label)

    Returns:
        self

    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="creme.base.Classifier.predict_one"><code class="name flex">
<span>def <span class="ident">predict_one</span></span>(<span>self, x: dict) -> Union[Hashable, NoneType]</span>
</code></dt>
<dd>
<section class="desc"><p>Predicts the target value of a set of features <code>x</code>.</p>
<h2 id="parameters">Parameters</h2>
<p>x (dict)</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Label</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def predict_one(self, x: dict) -&gt; typing.Union[typing.Hashable, None]:
    &#34;&#34;&#34;Predicts the target value of a set of features ``x``.

    Parameters:
        x (dict)

    Returns:
        Label

    &#34;&#34;&#34;
    y_pred = self.predict_proba_one(x)
    if y_pred:
        return max(y_pred, key=y_pred.get)
    return None</code></pre>
</details>
</dd>
<dt id="creme.base.Classifier.predict_proba_one"><code class="name flex">
<span>def <span class="ident">predict_proba_one</span></span>(<span>self, x)</span>
</code></dt>
<dd>
<section class="desc"><p>Predicts the probability output of a set of features <code>x</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def predict_proba_one(self, x):
    &#34;&#34;&#34;Predicts the probability output of a set of features ``x``.&#34;&#34;&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="creme.base.Clusterer"><code class="flex name class">
<span>class <span class="ident">Clusterer</span></span>
</code></dt>
<dd>
<section class="desc"><p>A clusterer.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Clusterer(estimator.Estimator):
    &#34;&#34;&#34;A clusterer.&#34;&#34;&#34;

    @abc.abstractmethod
    def fit_one(self, x: dict) -&gt; &#39;Clusterer&#39;:
        &#34;&#34;&#34;Fits to a set of features ``x``.

        Parameters:
            x (dict)

        Returns:
            self

        &#34;&#34;&#34;

    @abc.abstractmethod
    def predict_one(self, x: dict) -&gt; int:
        &#34;&#34;&#34;Predicts the cluster number of a set of features ``x``.

        Parameters:
            x (dict)

        Returns:
            int

        &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="creme.base.estimator.Estimator" href="estimator.html#creme.base.estimator.Estimator">Estimator</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>creme.cluster.k_means.KMeans</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="creme.base.Clusterer.fit_one"><code class="name flex">
<span>def <span class="ident">fit_one</span></span>(<span>self, x: dict) -> <a title="creme.base.clusterer.Clusterer" href="clusterer.html#creme.base.clusterer.Clusterer">Clusterer</a></span>
</code></dt>
<dd>
<section class="desc"><p>Fits to a set of features <code>x</code>.</p>
<h2 id="parameters">Parameters</h2>
<p>x (dict)</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>self</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def fit_one(self, x: dict) -&gt; &#39;Clusterer&#39;:
    &#34;&#34;&#34;Fits to a set of features ``x``.

    Parameters:
        x (dict)

    Returns:
        self

    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="creme.base.Clusterer.predict_one"><code class="name flex">
<span>def <span class="ident">predict_one</span></span>(<span>self, x: dict) -> int</span>
</code></dt>
<dd>
<section class="desc"><p>Predicts the cluster number of a set of features <code>x</code>.</p>
<h2 id="parameters">Parameters</h2>
<p>x (dict)</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def predict_one(self, x: dict) -&gt; int:
    &#34;&#34;&#34;Predicts the cluster number of a set of features ``x``.

    Parameters:
        x (dict)

    Returns:
        int

    &#34;&#34;&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="creme.base.Ensemble"><code class="flex name class">
<span>class <span class="ident">Ensemble</span></span>
<span>(</span><span>initlist=None)</span>
</code></dt>
<dd>
<section class="desc"><p>An ensemble model.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Ensemble(estimator.Estimator, collections.UserList):
    &#34;&#34;&#34;An ensemble model.&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="creme.base.estimator.Estimator" href="estimator.html#creme.base.estimator.Estimator">Estimator</a></li>
<li>abc.ABC</li>
<li>collections.UserList</li>
<li>collections.abc.MutableSequence</li>
<li>collections.abc.Sequence</li>
<li>collections.abc.Reversible</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>creme.ensemble.bagging.BaseBagging</li>
<li>creme.ensemble.boosting.BaseBoosting</li>
<li>creme.ensemble.hedging.HedgeRegressor</li>
<li>creme.ensemble.stacking.StackingBinaryClassifier</li>
</ul>
</dd>
<dt id="creme.base.Estimator"><code class="flex name class">
<span>class <span class="ident">Estimator</span></span>
</code></dt>
<dd>
<section class="desc"><p>An estimator.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Estimator(abc.ABC):
    &#34;&#34;&#34;An estimator.&#34;&#34;&#34;

    def __str__(self):
        return self.__class__.__name__

    def __repr__(self):
        return _repr_obj(obj=self, params=self._get_params())

    def _get_params(self) -&gt; typing.Dict[str, typing.Any]:
        return {
            name: getattr(self, name)
            for name, param in inspect.signature(self.__init__).parameters.items()  # type: ignore
            if param.kind != param.VAR_KEYWORD
        }

    def _set_params(self, new_params: typing.Optional[typing.Dict[str, typing.Any]] = None) -&gt; &#39;Estimator&#39;:
        &#34;&#34;&#34;Returns a new instance with the current parameters as well as new ones.

        The algorithm will be recursively called down ``Pipeline``s and ``TransformerUnion``s.

        Example:

            ::

                &gt;&gt;&gt; from creme import linear_model
                &gt;&gt;&gt; from creme import optim
                &gt;&gt;&gt; from creme import preprocessing

                &gt;&gt;&gt; model = (
                ...     preprocessing.StandardScaler() |
                ...     linear_model.LinearRegression(
                ...         optimizer=optim.SGD(lr=0.042),
                ...     )
                ... )

                &gt;&gt;&gt; new_params = {
                ...     &#39;LinearRegression&#39;: {
                ...         &#39;l2&#39;: .001
                ...     }
                ... }

                &gt;&gt;&gt; model._set_params(new_params)
                Pipeline (
                  StandardScaler (
                    with_mean=True
                    with_std=True
                  ),
                  LinearRegression (
                    optimizer=SGD (
                      lr=Constant (
                        learning_rate=0.042
                      )
                    )
                    loss=Squared ()
                    l2=0.001
                    intercept=0.
                    intercept_lr=Constant (
                      learning_rate=0.01
                    )
                    clip_gradient=1e+12
                    initializer=Zeros ()
                  )
                )

        &#34;&#34;&#34;

        if new_params is None:
            new_params = {}

        params = {
            **self._get_params(),
            **new_params
        }

        return self.__class__(**copy.deepcopy(params))  # type: ignore

    @property
    def _tags(self) -&gt; typing.Dict[str, bool]:
        &#34;&#34;&#34;Returns the estimator&#39;s tags.

        Tags can be used to specify what kind of inputs an estimator is able to process. For
        instance, some estimators can handle text, whilst others require positive numeric data.
        Inheriting from `base.Estimator` will imply a set of default tags which can be overrided
        by implementing the `base.Estimator._more_tags` method.

        &#34;&#34;&#34;

        tags: typing.Dict[str, bool] = {}

        for base_class in inspect.getmro(self.__class__)[1:]:
            if isinstance(base_class, Estimator):
                _update_if_consistent(tags, base_class._more_tags)

        _update_if_consistent(tags, self._more_tags)

        return {**DEFAULT_TAGS, **tags}

    @property
    def _more_tags(self) -&gt; typing.Dict[str, bool]:
        &#34;&#34;&#34;Specific tags for this estimator.&#34;&#34;&#34;
        return {}

    @property
    def _memory_usage(self) -&gt; str:
        &#34;&#34;&#34;Returns the memory usage in a human readable format.&#34;&#34;&#34;

        def get_size(obj, seen=None):
            &#34;&#34;&#34;Recursively finds size of objects&#34;&#34;&#34;
            size = sys.getsizeof(obj)
            if seen is None:
                seen = set()
            obj_id = id(obj)
            if obj_id in seen:
                return 0
            # Important mark as seen *before* entering recursion to gracefully handle
            # self-referential objects
            seen.add(obj_id)
            if isinstance(obj, dict):
                size += sum([get_size(v, seen) for v in obj.values()])
                size += sum([get_size(k, seen) for k in obj.keys()])
            elif hasattr(obj, &#39;__dict__&#39;):
                size += get_size(vars(obj), seen)
            elif hasattr(obj, &#39;__iter__&#39;) and not isinstance(obj, (str, bytes, bytearray)):
                size += sum([get_size(i, seen) for i in obj])
            return size

        mem_usage = get_size(self)
        return utils.pretty.humanize_bytes(mem_usage)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="creme.base.anomaly.AnomalyDetector" href="anomaly.html#creme.base.anomaly.AnomalyDetector">AnomalyDetector</a></li>
<li><a title="creme.base.classifier.Classifier" href="classifier.html#creme.base.classifier.Classifier">Classifier</a></li>
<li><a title="creme.base.clusterer.Clusterer" href="clusterer.html#creme.base.clusterer.Clusterer">Clusterer</a></li>
<li><a title="creme.base.ensemble.Ensemble" href="ensemble.html#creme.base.ensemble.Ensemble">Ensemble</a></li>
<li><a title="creme.base.multi_output.MultiOutputEstimator" href="multi_output.html#creme.base.multi_output.MultiOutputEstimator">MultiOutputEstimator</a></li>
<li><a title="creme.base.regressor.Regressor" href="regressor.html#creme.base.regressor.Regressor">Regressor</a></li>
<li><a title="creme.base.transformer.Transformer" href="transformer.html#creme.base.transformer.Transformer">Transformer</a></li>
<li><a title="creme.base.wrapper.Wrapper" href="wrapper.html#creme.base.wrapper.Wrapper">Wrapper</a></li>
<li>creme.compose.pipeline.Pipeline</li>
<li>creme.time_series.base.Forecaster</li>
</ul>
</dd>
<dt id="creme.base.MultiClassifier"><code class="flex name class">
<span>class <span class="ident">MultiClassifier</span></span>
</code></dt>
<dd>
<section class="desc"><p>A multi-class classifier.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MultiClassifier(Classifier):
    &#34;&#34;&#34;A multi-class classifier.&#34;&#34;&#34;

    @abc.abstractmethod
    def fit_one(self, x: dict, y: typing.Hashable) -&gt; &#39;Classifier&#39;:
        &#34;&#34;&#34;Fits to a set of features ``x`` and a label ``y``.

        Parameters:
            x (dict)
            y (Label)

        Returns:
            self

        &#34;&#34;&#34;

    @abc.abstractmethod
    def predict_proba_one(self, x: dict) -&gt; typing.Dict[typing.Hashable, float]:
        &#34;&#34;&#34;Predicts the probability output of a set of features ``x``.&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="creme.base.classifier.Classifier" href="classifier.html#creme.base.classifier.Classifier">Classifier</a></li>
<li><a title="creme.base.estimator.Estimator" href="estimator.html#creme.base.estimator.Estimator">Estimator</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>creme.compat.sklearn.SKL2CremeClassifier</li>
<li>creme.dummy.NoChangeClassifier</li>
<li>creme.dummy.PriorClassifier</li>
<li>creme.linear_model.softmax.SoftmaxRegression</li>
<li>creme.multiclass.ovr.OneVsRestClassifier</li>
<li>creme.naive_bayes.base.BaseNB</li>
<li><a title="creme.neighbors.knn.KNeighborsClassifier" href="../neighbors/knn.html#creme.neighbors.knn.KNeighborsClassifier">KNeighborsClassifier</a></li>
<li>creme.tree.decision.tree.DecisionTreeClassifier</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="creme.base.MultiClassifier.fit_one"><code class="name flex">
<span>def <span class="ident">fit_one</span></span>(<span>self, x: dict, y: Hashable) -> <a title="creme.base.classifier.Classifier" href="classifier.html#creme.base.classifier.Classifier">Classifier</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="creme.base.classifier.Classifier" href="classifier.html#creme.base.classifier.Classifier">Classifier</a></code>.<code><a title="creme.base.classifier.Classifier.fit_one" href="classifier.html#creme.base.classifier.Classifier.fit_one">fit_one</a></code>
</p>
<section class="desc inherited"><p>Fits to a set of features <code>x</code> and a label <code>y</code> …</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def fit_one(self, x: dict, y: typing.Hashable) -&gt; &#39;Classifier&#39;:
    &#34;&#34;&#34;Fits to a set of features ``x`` and a label ``y``.

    Parameters:
        x (dict)
        y (Label)

    Returns:
        self

    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="creme.base.MultiClassifier.predict_one"><code class="name flex">
<span>def <span class="ident">predict_one</span></span>(<span>self, x: dict) -> Union[Hashable, NoneType]</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="creme.base.classifier.Classifier" href="classifier.html#creme.base.classifier.Classifier">Classifier</a></code>.<code><a title="creme.base.classifier.Classifier.predict_one" href="classifier.html#creme.base.classifier.Classifier.predict_one">predict_one</a></code>
</p>
<section class="desc inherited"><p>Predicts the target value of a set of features <code>x</code> …</p></section>
</dd>
<dt id="creme.base.MultiClassifier.predict_proba_one"><code class="name flex">
<span>def <span class="ident">predict_proba_one</span></span>(<span>self, x: dict) -> Dict[Hashable, float]</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="creme.base.classifier.Classifier" href="classifier.html#creme.base.classifier.Classifier">Classifier</a></code>.<code><a title="creme.base.classifier.Classifier.predict_proba_one" href="classifier.html#creme.base.classifier.Classifier.predict_proba_one">predict_proba_one</a></code>
</p>
<section class="desc inherited"><p>Predicts the probability output of a set of features <code>x</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def predict_proba_one(self, x: dict) -&gt; typing.Dict[typing.Hashable, float]:
    &#34;&#34;&#34;Predicts the probability output of a set of features ``x``.&#34;&#34;&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="creme.base.MultiOutputClassifier"><code class="flex name class">
<span>class <span class="ident">MultiOutputClassifier</span></span>
</code></dt>
<dd>
<section class="desc"><p>A multi-output classifier.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MultiOutputClassifier(MultiOutputEstimator):
    &#34;&#34;&#34;A multi-output classifier.&#34;&#34;&#34;

    @abc.abstractmethod
    def fit_one(self, x: dict, y: typing.Dict[typing.Hashable, typing.Hashable]) -&gt; &#39;MultiOutputClassifier&#39;:
        &#34;&#34;&#34;Fits to a set of features ``x`` and a set of labels ``y``.

        Parameters:
            x (dict)
            y (dict of Label)

        Returns:
            self

        &#34;&#34;&#34;

    @abc.abstractmethod
    def predict_proba_one(self, x: dict) -&gt; typing.Dict[typing.Hashable, typing.Dict[typing.Hashable, float]]:
        &#34;&#34;&#34;Given a set of features ``x``, predicts a the probability of each label for each output.

        Parameters:
            x (dict)

        Returns:

        &#34;&#34;&#34;

    def predict_one(self, x: dict) -&gt; typing.Dict[typing.Hashable, typing.Hashable]:
        &#34;&#34;&#34;Given a set of features ``x``, predicts a label for each output.

        Parameters:
            x (dict)

        Returns:

        &#34;&#34;&#34;
        y_pred = self.predict_proba_one(x)
        return {
            c: max(y_pred[c], key=y_pred[c].get)
            for c in y_pred
        }</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="creme.base.multi_output.MultiOutputEstimator" href="multi_output.html#creme.base.multi_output.MultiOutputEstimator">MultiOutputEstimator</a></li>
<li><a title="creme.base.estimator.Estimator" href="estimator.html#creme.base.estimator.Estimator">Estimator</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>creme.multioutput.chain.ClassifierChain</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="creme.base.MultiOutputClassifier.fit_one"><code class="name flex">
<span>def <span class="ident">fit_one</span></span>(<span>self, x: dict, y: Dict[Hashable, Hashable]) -> <a title="creme.base.multi_output.MultiOutputClassifier" href="multi_output.html#creme.base.multi_output.MultiOutputClassifier">MultiOutputClassifier</a></span>
</code></dt>
<dd>
<section class="desc"><p>Fits to a set of features <code>x</code> and a set of labels <code>y</code>.</p>
<h2 id="parameters">Parameters</h2>
<p>x (dict)
y (dict of Label)</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>self</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def fit_one(self, x: dict, y: typing.Dict[typing.Hashable, typing.Hashable]) -&gt; &#39;MultiOutputClassifier&#39;:
    &#34;&#34;&#34;Fits to a set of features ``x`` and a set of labels ``y``.

    Parameters:
        x (dict)
        y (dict of Label)

    Returns:
        self

    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="creme.base.MultiOutputClassifier.predict_one"><code class="name flex">
<span>def <span class="ident">predict_one</span></span>(<span>self, x: dict) -> Dict[Hashable, Hashable]</span>
</code></dt>
<dd>
<section class="desc"><p>Given a set of features <code>x</code>, predicts a label for each output.</p>
<h2 id="parameters">Parameters</h2>
<p>x (dict)
Returns:</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def predict_one(self, x: dict) -&gt; typing.Dict[typing.Hashable, typing.Hashable]:
    &#34;&#34;&#34;Given a set of features ``x``, predicts a label for each output.

    Parameters:
        x (dict)

    Returns:

    &#34;&#34;&#34;
    y_pred = self.predict_proba_one(x)
    return {
        c: max(y_pred[c], key=y_pred[c].get)
        for c in y_pred
    }</code></pre>
</details>
</dd>
<dt id="creme.base.MultiOutputClassifier.predict_proba_one"><code class="name flex">
<span>def <span class="ident">predict_proba_one</span></span>(<span>self, x: dict) -> Dict[Hashable, Dict[Hashable, float]]</span>
</code></dt>
<dd>
<section class="desc"><p>Given a set of features <code>x</code>, predicts a the probability of each label for each output.</p>
<h2 id="parameters">Parameters</h2>
<p>x (dict)
Returns:</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def predict_proba_one(self, x: dict) -&gt; typing.Dict[typing.Hashable, typing.Dict[typing.Hashable, float]]:
    &#34;&#34;&#34;Given a set of features ``x``, predicts a the probability of each label for each output.

    Parameters:
        x (dict)

    Returns:

    &#34;&#34;&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="creme.base.MultiOutputRegressor"><code class="flex name class">
<span>class <span class="ident">MultiOutputRegressor</span></span>
</code></dt>
<dd>
<section class="desc"><p>A multi-output regressor.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MultiOutputRegressor(MultiOutputEstimator):
    &#34;&#34;&#34;A multi-output regressor.&#34;&#34;&#34;

    @abc.abstractmethod
    def fit_one(self, x: dict, y: typing.Dict[typing.Hashable, float]) -&gt; &#39;MultiOutputRegressor&#39;:
        &#34;&#34;&#34;Fits to a set of features ``x`` and a set of outputs ``y``.

        Parameters:
            x (dict)
            y (dict of Label)

        Returns:
            self

        &#34;&#34;&#34;

    @abc.abstractmethod
    def predict_one(self, x: dict) -&gt; typing.Dict[typing.Hashable, float]:
        &#34;&#34;&#34;Given a set of features ``x``, predicts a label for each output.

        Parameters:
            x (dict)

        Returns:
            dict

        &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="creme.base.multi_output.MultiOutputEstimator" href="multi_output.html#creme.base.multi_output.MultiOutputEstimator">MultiOutputEstimator</a></li>
<li><a title="creme.base.estimator.Estimator" href="estimator.html#creme.base.estimator.Estimator">Estimator</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>creme.multioutput.chain.RegressorChain</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="creme.base.MultiOutputRegressor.fit_one"><code class="name flex">
<span>def <span class="ident">fit_one</span></span>(<span>self, x: dict, y: Dict[Hashable, float]) -> <a title="creme.base.multi_output.MultiOutputRegressor" href="multi_output.html#creme.base.multi_output.MultiOutputRegressor">MultiOutputRegressor</a></span>
</code></dt>
<dd>
<section class="desc"><p>Fits to a set of features <code>x</code> and a set of outputs <code>y</code>.</p>
<h2 id="parameters">Parameters</h2>
<p>x (dict)
y (dict of Label)</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>self</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def fit_one(self, x: dict, y: typing.Dict[typing.Hashable, float]) -&gt; &#39;MultiOutputRegressor&#39;:
    &#34;&#34;&#34;Fits to a set of features ``x`` and a set of outputs ``y``.

    Parameters:
        x (dict)
        y (dict of Label)

    Returns:
        self

    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="creme.base.MultiOutputRegressor.predict_one"><code class="name flex">
<span>def <span class="ident">predict_one</span></span>(<span>self, x: dict) -> Dict[Hashable, float]</span>
</code></dt>
<dd>
<section class="desc"><p>Given a set of features <code>x</code>, predicts a label for each output.</p>
<h2 id="parameters">Parameters</h2>
<p>x (dict)</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def predict_one(self, x: dict) -&gt; typing.Dict[typing.Hashable, float]:
    &#34;&#34;&#34;Given a set of features ``x``, predicts a label for each output.

    Parameters:
        x (dict)

    Returns:
        dict

    &#34;&#34;&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="creme.base.Regressor"><code class="flex name class">
<span>class <span class="ident">Regressor</span></span>
</code></dt>
<dd>
<section class="desc"><p>A regressor.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Regressor(estimator.Estimator):
    &#34;&#34;&#34;A regressor.&#34;&#34;&#34;

    @abc.abstractmethod
    def fit_one(self, x: dict, y: typing.Union[float, int]) -&gt; &#39;Regressor&#39;:
        &#34;&#34;&#34;Fits to a set of features ``x`` and a real-valued target ``y``.

        Parameters:
            x (dict)
            y (float)

        Returns:
            self: object

        &#34;&#34;&#34;

    @abc.abstractmethod
    def predict_one(self, x: dict) -&gt; float:
        &#34;&#34;&#34;Predicts the target value of a set of features ``x``.

        Parameters:
            x (dict)

        Returns:
            float: The prediction.

        &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="creme.base.estimator.Estimator" href="estimator.html#creme.base.estimator.Estimator">Estimator</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>creme.compat.pytorch.PyTorch2CremeRegressor</li>
<li>creme.compat.sklearn.SKL2CremeRegressor</li>
<li>creme.dummy.StatisticRegressor</li>
<li>creme.ensemble.bagging.BaggingRegressor</li>
<li>creme.ensemble.hedging.HedgeRegressor</li>
<li>creme.facto.ffm.FFMRegressor</li>
<li>creme.facto.fm.FMRegressor</li>
<li>creme.facto.fwfm.FwFMRegressor</li>
<li>creme.facto.hofm.HOFMRegressor</li>
<li>creme.linear_model.glm.LinearRegression</li>
<li>creme.linear_model.pa.PARegressor</li>
<li>creme.meta.pred_clipper.PredClipper</li>
<li>creme.meta.target_transform.TransformedTargetRegressor</li>
<li>creme.model_selection.sh.SuccessiveHalvingRegressor</li>
<li><a title="creme.neighbors.knn.KNeighborsRegressor" href="../neighbors/knn.html#creme.neighbors.knn.KNeighborsRegressor">KNeighborsRegressor</a></li>
<li>creme.reco.base.Recommender</li>
<li>creme.time_series.detrender.Detrender</li>
<li>creme.time_series.detrender.GroupDetrender</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="creme.base.Regressor.fit_one"><code class="name flex">
<span>def <span class="ident">fit_one</span></span>(<span>self, x: dict, y: Union[float, int]) -> <a title="creme.base.regressor.Regressor" href="regressor.html#creme.base.regressor.Regressor">Regressor</a></span>
</code></dt>
<dd>
<section class="desc"><p>Fits to a set of features <code>x</code> and a real-valued target <code>y</code>.</p>
<h2 id="parameters">Parameters</h2>
<p>x (dict)
y (float)</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>self</code></strong></dt>
<dd>object</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def fit_one(self, x: dict, y: typing.Union[float, int]) -&gt; &#39;Regressor&#39;:
    &#34;&#34;&#34;Fits to a set of features ``x`` and a real-valued target ``y``.

    Parameters:
        x (dict)
        y (float)

    Returns:
        self: object

    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="creme.base.Regressor.predict_one"><code class="name flex">
<span>def <span class="ident">predict_one</span></span>(<span>self, x: dict) -> float</span>
</code></dt>
<dd>
<section class="desc"><p>Predicts the target value of a set of features <code>x</code>.</p>
<h2 id="parameters">Parameters</h2>
<p>x (dict)</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>float</code></strong></dt>
<dd>The prediction.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def predict_one(self, x: dict) -&gt; float:
    &#34;&#34;&#34;Predicts the target value of a set of features ``x``.

    Parameters:
        x (dict)

    Returns:
        float: The prediction.

    &#34;&#34;&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="creme.base.Transformer"><code class="flex name class">
<span>class <span class="ident">Transformer</span></span>
</code></dt>
<dd>
<section class="desc"><p>A transformer.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Transformer(estimator.Estimator):
    &#34;&#34;&#34;A transformer.&#34;&#34;&#34;

    def fit_one(self, x: dict, y=None) -&gt; &#39;Transformer&#39;:
        &#34;&#34;&#34;Fits to a set of features ``x`` and an optional target ``y``.

        A lot of transformers don&#39;t actually have to do anything during the ``fit_one`` step
        because they are stateless. For this reason the default behavior of this function is to do
        nothing. Transformers that however do something during the ``fit_one`` can override this
        method.

        Parameters:
            x (dict)
            y (optional)

        Returns:
            self

        &#34;&#34;&#34;
        return self

    @abc.abstractmethod
    def transform_one(self, x: dict) -&gt; dict:
        &#34;&#34;&#34;Transforms a set of features ``x``.

        Parameters:
            x (dict)

        Returns:
            dict

        &#34;&#34;&#34;

    @property
    def is_supervised(self) -&gt; bool:
        &#34;&#34;&#34;Indicates if the transformer uses the target ``y`` or not.

        Supervised transformers have to be handled differently from unsupervised transformers in an
        online setting. This is especially true for target encoding where leakage can easily occur.
        Most transformers are unsupervised and so this property returns by default ``False``.
        Transformers that are supervised must override this property in their definition.

        &#34;&#34;&#34;
        return False

    def __or__(self, other):
        &#34;&#34;&#34;Merges with another Transformer into a Pipeline.&#34;&#34;&#34;
        from .. import compose
        if isinstance(other, compose.Pipeline):
            return other.__ror__(self)
        return compose.Pipeline(self, other)

    def __ror__(self, other):
        &#34;&#34;&#34;Merges with another Transformer into a Pipeline.&#34;&#34;&#34;
        from .. import compose
        if isinstance(other, compose.Pipeline):
            return other.__or__(self)
        return compose.Pipeline(other, self)

    def __add__(self, other):
        &#34;&#34;&#34;Merges with another Transformer into a TransformerUnion.&#34;&#34;&#34;
        from .. import compose
        if isinstance(other, compose.TransformerUnion):
            return other.__add__(self)
        return compose.TransformerUnion(self, other)

    def __radd__(self, other):
        &#34;&#34;&#34;Merges with another Transformer into a TransformerUnion.&#34;&#34;&#34;
        from .. import compose
        if isinstance(other, compose.TransformerUnion):
            return other.__add__(self)
        return compose.TransformerUnion(other, self)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="creme.base.estimator.Estimator" href="estimator.html#creme.base.estimator.Estimator">Estimator</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>creme.compose.func.FuncTransformer</li>
<li>creme.compose.rename.Renamer</li>
<li>creme.compose.select.Discard</li>
<li>creme.compose.select.Select</li>
<li>creme.compose.union.TransformerUnion</li>
<li>creme.decomposition.lda.LDA</li>
<li>creme.feature_extraction.agg.Agg</li>
<li>creme.feature_extraction.agg.TargetAgg</li>
<li>creme.feature_extraction.differ.Differ</li>
<li>creme.feature_extraction.vectorize.BagOfWords</li>
<li>creme.feature_selection.k_best.SelectKBest</li>
<li>creme.feature_selection.random.PoissonInclusion</li>
<li>creme.feature_selection.variance.VarianceThreshold</li>
<li>creme.impute.previous.PreviousImputer</li>
<li>creme.impute.stat.StatImputer</li>
<li>creme.preprocessing.feature_hasher.FeatureHasher</li>
<li>creme.preprocessing.kernel_approx.RBFSampler</li>
<li>creme.preprocessing.one_hot.OneHotEncoder</li>
<li>creme.preprocessing.poly.PolynomialExtender</li>
<li>creme.preprocessing.scale.Binarizer</li>
<li>creme.preprocessing.scale.MaxAbsScaler</li>
<li>creme.preprocessing.scale.MinMaxScaler</li>
<li>creme.preprocessing.scale.Normalizer</li>
<li>creme.preprocessing.scale.RobustScaler</li>
<li>creme.preprocessing.scale.StandardScaler</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="creme.base.Transformer.is_supervised"><code class="name">var <span class="ident">is_supervised</span></code></dt>
<dd>
<section class="desc"><p>Indicates if the transformer uses the target <code>y</code> or not.</p>
<p>Supervised transformers have to be handled differently from unsupervised transformers in an
online setting. This is especially true for target encoding where leakage can easily occur.
Most transformers are unsupervised and so this property returns by default <code>False</code>.
Transformers that are supervised must override this property in their definition.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_supervised(self) -&gt; bool:
    &#34;&#34;&#34;Indicates if the transformer uses the target ``y`` or not.

    Supervised transformers have to be handled differently from unsupervised transformers in an
    online setting. This is especially true for target encoding where leakage can easily occur.
    Most transformers are unsupervised and so this property returns by default ``False``.
    Transformers that are supervised must override this property in their definition.

    &#34;&#34;&#34;
    return False</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="creme.base.Transformer.fit_one"><code class="name flex">
<span>def <span class="ident">fit_one</span></span>(<span>self, x: dict, y=None) -> <a title="creme.base.transformer.Transformer" href="transformer.html#creme.base.transformer.Transformer">Transformer</a></span>
</code></dt>
<dd>
<section class="desc"><p>Fits to a set of features <code>x</code> and an optional target <code>y</code>.</p>
<p>A lot of transformers don't actually have to do anything during the <code>fit_one</code> step
because they are stateless. For this reason the default behavior of this function is to do
nothing. Transformers that however do something during the <code>fit_one</code> can override this
method.</p>
<h2 id="parameters">Parameters</h2>
<p>x (dict)
y (optional)</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>self</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fit_one(self, x: dict, y=None) -&gt; &#39;Transformer&#39;:
    &#34;&#34;&#34;Fits to a set of features ``x`` and an optional target ``y``.

    A lot of transformers don&#39;t actually have to do anything during the ``fit_one`` step
    because they are stateless. For this reason the default behavior of this function is to do
    nothing. Transformers that however do something during the ``fit_one`` can override this
    method.

    Parameters:
        x (dict)
        y (optional)

    Returns:
        self

    &#34;&#34;&#34;
    return self</code></pre>
</details>
</dd>
<dt id="creme.base.Transformer.transform_one"><code class="name flex">
<span>def <span class="ident">transform_one</span></span>(<span>self, x: dict) -> dict</span>
</code></dt>
<dd>
<section class="desc"><p>Transforms a set of features <code>x</code>.</p>
<h2 id="parameters">Parameters</h2>
<p>x (dict)</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def transform_one(self, x: dict) -&gt; dict:
    &#34;&#34;&#34;Transforms a set of features ``x``.

    Parameters:
        x (dict)

    Returns:
        dict

    &#34;&#34;&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="creme.base.Wrapper"><code class="flex name class">
<span>class <span class="ident">Wrapper</span></span>
</code></dt>
<dd>
<section class="desc"><p>A wrapper model.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Wrapper(estimator.Estimator):
    &#34;&#34;&#34;A wrapper model.&#34;&#34;&#34;

    @abc.abstractproperty
    def _model(self):
        &#34;&#34;&#34;Provides access to the wrapped model.&#34;&#34;&#34;

    @property
    def _labelloc(self):
        &#34;&#34;&#34;Indicates location of the wrapper name when drawing pipelines.&#34;&#34;&#34;
        return &#39;t&#39;  # for top

    def __str__(self):
        return f&#39;{type(self).__name__}({self._model})&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="creme.base.estimator.Estimator" href="estimator.html#creme.base.estimator.Estimator">Estimator</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>creme.ensemble.bagging.BaseBagging</li>
<li>creme.ensemble.boosting.BaseBoosting</li>
<li>creme.meta.pred_clipper.PredClipper</li>
<li>creme.meta.target_transform.TransformedTargetRegressor</li>
<li>creme.multioutput.chain.BaseChain</li>
<li>creme.sampling.hard_sampling.HardSampling</li>
<li>creme.sampling.random.ClassificationSampler</li>
<li>creme.time_series.detrender.Detrender</li>
<li>creme.time_series.detrender.GroupDetrender</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="creme" href="../index.html">creme</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="creme.base.anomaly" href="anomaly.html">creme.base.anomaly</a></code></li>
<li><code><a title="creme.base.classifier" href="classifier.html">creme.base.classifier</a></code></li>
<li><code><a title="creme.base.clusterer" href="clusterer.html">creme.base.clusterer</a></code></li>
<li><code><a title="creme.base.ensemble" href="ensemble.html">creme.base.ensemble</a></code></li>
<li><code><a title="creme.base.estimator" href="estimator.html">creme.base.estimator</a></code></li>
<li><code><a title="creme.base.multi_output" href="multi_output.html">creme.base.multi_output</a></code></li>
<li><code><a title="creme.base.regressor" href="regressor.html">creme.base.regressor</a></code></li>
<li><code><a title="creme.base.test_base" href="test_base.html">creme.base.test_base</a></code></li>
<li><code><a title="creme.base.transformer" href="transformer.html">creme.base.transformer</a></code></li>
<li><code><a title="creme.base.wrapper" href="wrapper.html">creme.base.wrapper</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="creme.base.AnomalyDetector" href="#creme.base.AnomalyDetector">AnomalyDetector</a></code></h4>
<ul class="">
<li><code><a title="creme.base.AnomalyDetector.fit_one" href="#creme.base.AnomalyDetector.fit_one">fit_one</a></code></li>
<li><code><a title="creme.base.AnomalyDetector.score_one" href="#creme.base.AnomalyDetector.score_one">score_one</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="creme.base.BinaryClassifier" href="#creme.base.BinaryClassifier">BinaryClassifier</a></code></h4>
<ul class="">
<li><code><a title="creme.base.BinaryClassifier.fit_one" href="#creme.base.BinaryClassifier.fit_one">fit_one</a></code></li>
<li><code><a title="creme.base.BinaryClassifier.predict_one" href="#creme.base.BinaryClassifier.predict_one">predict_one</a></code></li>
<li><code><a title="creme.base.BinaryClassifier.predict_proba_one" href="#creme.base.BinaryClassifier.predict_proba_one">predict_proba_one</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="creme.base.Classifier" href="#creme.base.Classifier">Classifier</a></code></h4>
<ul class="">
<li><code><a title="creme.base.Classifier.fit_one" href="#creme.base.Classifier.fit_one">fit_one</a></code></li>
<li><code><a title="creme.base.Classifier.predict_one" href="#creme.base.Classifier.predict_one">predict_one</a></code></li>
<li><code><a title="creme.base.Classifier.predict_proba_one" href="#creme.base.Classifier.predict_proba_one">predict_proba_one</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="creme.base.Clusterer" href="#creme.base.Clusterer">Clusterer</a></code></h4>
<ul class="">
<li><code><a title="creme.base.Clusterer.fit_one" href="#creme.base.Clusterer.fit_one">fit_one</a></code></li>
<li><code><a title="creme.base.Clusterer.predict_one" href="#creme.base.Clusterer.predict_one">predict_one</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="creme.base.Ensemble" href="#creme.base.Ensemble">Ensemble</a></code></h4>
</li>
<li>
<h4><code><a title="creme.base.Estimator" href="#creme.base.Estimator">Estimator</a></code></h4>
</li>
<li>
<h4><code><a title="creme.base.MultiClassifier" href="#creme.base.MultiClassifier">MultiClassifier</a></code></h4>
<ul class="">
<li><code><a title="creme.base.MultiClassifier.fit_one" href="#creme.base.MultiClassifier.fit_one">fit_one</a></code></li>
<li><code><a title="creme.base.MultiClassifier.predict_one" href="classifier.html#creme.base.MultiClassifier.predict_one">predict_one</a></code></li>
<li><code><a title="creme.base.MultiClassifier.predict_proba_one" href="#creme.base.MultiClassifier.predict_proba_one">predict_proba_one</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="creme.base.MultiOutputClassifier" href="#creme.base.MultiOutputClassifier">MultiOutputClassifier</a></code></h4>
<ul class="">
<li><code><a title="creme.base.MultiOutputClassifier.fit_one" href="#creme.base.MultiOutputClassifier.fit_one">fit_one</a></code></li>
<li><code><a title="creme.base.MultiOutputClassifier.predict_one" href="#creme.base.MultiOutputClassifier.predict_one">predict_one</a></code></li>
<li><code><a title="creme.base.MultiOutputClassifier.predict_proba_one" href="#creme.base.MultiOutputClassifier.predict_proba_one">predict_proba_one</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="creme.base.MultiOutputRegressor" href="#creme.base.MultiOutputRegressor">MultiOutputRegressor</a></code></h4>
<ul class="">
<li><code><a title="creme.base.MultiOutputRegressor.fit_one" href="#creme.base.MultiOutputRegressor.fit_one">fit_one</a></code></li>
<li><code><a title="creme.base.MultiOutputRegressor.predict_one" href="#creme.base.MultiOutputRegressor.predict_one">predict_one</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="creme.base.Regressor" href="#creme.base.Regressor">Regressor</a></code></h4>
<ul class="">
<li><code><a title="creme.base.Regressor.fit_one" href="#creme.base.Regressor.fit_one">fit_one</a></code></li>
<li><code><a title="creme.base.Regressor.predict_one" href="#creme.base.Regressor.predict_one">predict_one</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="creme.base.Transformer" href="#creme.base.Transformer">Transformer</a></code></h4>
<ul class="">
<li><code><a title="creme.base.Transformer.fit_one" href="#creme.base.Transformer.fit_one">fit_one</a></code></li>
<li><code><a title="creme.base.Transformer.is_supervised" href="#creme.base.Transformer.is_supervised">is_supervised</a></code></li>
<li><code><a title="creme.base.Transformer.transform_one" href="#creme.base.Transformer.transform_one">transform_one</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="creme.base.Wrapper" href="#creme.base.Wrapper">Wrapper</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.5</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>